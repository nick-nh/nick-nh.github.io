---
layout: post
title: "maLib"
author: "nnh"
description: MA библиотека для Квик
tags: [lua,qlua,квик,quik]
---

Часто при написании скриптов и индикаторов требуются однотипные расчеты. Для примера - различные скользящие средние, осцилляторы и т.д.
Чтобы не дублировать одинаковый код в многочисленных файлах, необходимо вынести его в библиотеку.

Так была написана [MA Библиотека](https://github.com/nick-nh/qlua/blob/master/maLib.lua).

Чтобы ее использовать необходимо подключить ее к своему коду через типовой вызов:

#### local maLib = require("maLib")

Чтобы скрипт нашел библиотеку необходимо включить путь к каталогу, где расположена библиотека в переменную package.path:

#### package.path = path.."/?.lua;..package.path..';'

Либо воспользоваться функцией load:

#### local maLib = load(path.."\\maLib.lua")()

при этом необходимо указать полный путь к файлу.

После подключения станут доступны все публичные методы библиотеки:

 - new - создать экземпляр функции расчета по доступным методам<br>
 - Slice - получить срез массива по указанным индексам<br>
 - Sum - получить сумму элементов массива по указанным индексам<br>
 - wSum - получить weighted сумму элементов массива по указанным индексам<br>
 - Sigma - получить среднеквадратичное отклонение массива по указанным индексам<br>
 - Normalize - нормализовать массив, исключив минимальный и максимальный элементы<br>
 - Correlation - получить коэффициент корреляции Пирсона массива по указанным индексам<br>
 - EthlerAlpha - рассчитать John F. Ehlers Adaptive alfa<br>
 - Get2PoleSSF - рассчитать John F. Ehlers Deviation-Scaled filters<br>
 - Get3PoleSSF - рассчитать John F. Ehlers Deviation-Scaled filters<br>
 - CheckIndex - проверить что существует значение в массиве, потоке данных<br>
 - GetIndex - получить первый существующий индекс, смещенный от указанного (прошлый)<br>
 - rounding - округлить значение<br>
 - Value - получить значение из массива, потока данных<br>
 - dsSize - получить размер массива, потока данных<br>


Наиболее часто используемый метод - это new (создать экземпляр функции расчета по доступным методам). Собственно, с помощью этого метода можно получить типовые экземпляры функций расчета.

Для примера, создание экземпляра функции расчета EMA выглядит так:

#### local EMA = maLib.new({method = 'EMA', data_type = 'Close', period = 14}, ds)

где ds - это поток заказанных данных некого интервала.

Вызов этого же расчета внутри индикатора, где поток данных заказывать нет необходимости, будет выглядеть так:

#### local EMA = maLib.new({method = 'EMA', data_type = 'Close', period = 14})

т.е. просто не передается ссылка на поток данных.

Реализованные методы:

 - SMA - простая скользящая средняя
 - EMA - экспоненциальная скользящая средняя
 - SD - стандартное отклонение и простая скользящая средняя
 - VMA - нормированная на объем бара простоя скользящая средняя
 - SMMA - сглаженная простоя скользящая средняя
 - WMA - William скользящая средняя
 - LWMA - Произвольная (функция) - взвешенная скользящая средняя
 - HMA - Hull скользящая средняя
 - JMA - Jurik скользящая средняя
 - TEMA - тройная экспоненциальная скользящая средняя
 - FRAMA - фрактальная адаптивная скользящая средняя
 - AMA - адаптивная скользящая средняя Перри Кауфмана
 - ATR - Средний истинный диапазон
 - EFI - Elder's Force I
 - THV - скользящая средняя по стратегии THV
 - NRTR - [Nick Rypock Trailing Reverse от Константина Копыркина](http://konkop.narod.ru/Files/4_24_28.pdf).
 - NRMA - [Nick Rypoсk Moving Average - адаптивная скользящая средняя](http://konkop.narod.ru/nrma.htm).
 - REG - регрессия. Линейная, параболическая, кубическая
 - FLREG - Быстрая линейная регрессия.
 - KREG - Ядерная регрессия (kernel regression) с функциями ядра: gaussian; quartic biweight; epanechnikov
 - REMA - The Reverse EMA Indicator by John F. Ehlers
 - RENKO - Ренко бары
 - WRI  - WR (Williams' % Range)
 - MACD - осциллятор MACD
 - STOCH - осциллятор Стохастик
 - SMI Stochastic Momentum Index
 - RSI - осциллятор RSI
 - CCI - Индекс товарного канала
 - BOL - Линии Боллинджера (Bollinger bands)
 - SAR - реализация Parabolic SAR от Маркина Павла
 - PSAR - Классический Parabolic SAR
 - VWAP - Построение баров любых интервалов на основе баров базового интервала (1 Мин) + расчет приблизительный WVAP
 - ZZ  - Зиг-Заг
 - FRAC - Фракталы
 - CMO - Chande Momentum Oscillator
 - VIDYA - Variable Index Dynamic Average
 - DSMA - Deviation-Scaled Moving Average by John F. Ehlers

Также доступны вспомогательные функции:
 - Slice - выделить данные из массива для диапазона индексов
 - Sum - сумма данных массива для диапазона индексов
 - wSum - взвешенная (по индексу) сумма данных массива для диапазона индексов
 - Normalize - убрать из массива для диапазона индексов максимальное и минимальное значение
 - Sigma - Среднеквадратическое отклонение
 - Correlation - расчет коэффициента корреляции Пирсона|автокорреляции, ковариация
 - wave_processor - построение данных "волны": начало, окончание, макс. мин. значения, стд. отклонение, среднее размера волны

Список методов дополняется со временем.

Как видно из описания вызова метода new, вызов происходит с двумя параметрами:
 - settings - таблица с параметрами расчета
 - ds - поток данных или произвольный массив, над которыми производятся расчеты.

## Параметры settings

settings - это таблица, в которой присутствуют обязательное поле "method", задающее метод экземпляра функции для расчета.
В примере выше задается метод из списка - "EMA".

Параметр data_type не обязателен в случае расчета для потока данных. По умолчанию используется "Close" - цена закрытия бара.
Доступны значения, реализованные в функции Value:
 - Close - закрытие бара
 - High - максимум бара
 - Low - минимум бара
 - Open - открытие бара
 - Volume - объем бара
 - Median - как (High + low)/2
 - Typical - как (High + Low + Close)/3
 - Weighted - как (High + Low + Close + Open)/4
 - Difference - (High - Low)
 - Any - для расчетов над произвольным массивом

Также есть необязательный параметр save_bars, определяющий сколько индексов будет хранится в возвращаемом массиве результатов расчета. Это необходимо для оптимизации расхода памяти.

Параметры round и scale определяют необходимость округления возвращаемых результатов. По умолчанию round = "off" и scale = 0, т.е. округление не производится.

Остальные параметры определяются методом расчета. Допустим, для EMA необходим еще параметр period, а, скажем, для MACD необходимо указать больше параметров.

## Возвращаемые значения методов

Чаще всего возвращается массив или несколько массивов рассчитанных данных.

Метод EMA возвращает массив рассчитанных значений EMA. Метод MACD возвращает массивы значений MACD и сигнальной линии. И т.д. в зависимости от метода.

## Примеры использования

Для примера [индикатор, выводящий линию заданного метода](https://github.com/nick-nh/qlua/blob/master/MA.lua).
В данном индикаторе пользователем задается имя метода, значение периода.

Инициализация функции расчета:

#### fMA = maLib.new(Fsettings, ds)

 - Вызов для очередного индекса fMA(index)
 - Вызов и получение значения для очередного индекса fMA(index)[index]

Также на базе библиотеки написан [индикатор RENKO](https://nick-nh.github.io/2021-01-17/renko).

В самой библиотеке часть методов использует для расчета другие функции расчета. Для примера, тот же MACD, использует расчет EMA (или другой заданный метод) над потоком данных и над массивом.

-- Инициализация массива для хранения значений сигнальной линии<br>
#### local t_MACD    = {0}<br>
-- Создание экземпляра расчета по заданному методу над массивом t_MACD<br>
#### local MACD_MA   = M.new({period = signal_period, method = signal_method,   data_type = "Any",      round = round, scale = scale}, t_MACD)<br>
-- Создание экземпляра расчета по заданному методу над потоком данных<br>
#### local Short_MA  = M.new({period = short_period,  method = method,          data_type = data_type,  round = round, scale = scale}, ds)<br>
-- Создание экземпляра расчета по заданному методу над потоком данных<br>
#### local Long_MA   = M.new({period = long_period,   method = method,          data_type = data_type,  round = round, scale = scale}, ds)<br>

Т.е.создаются экземпляры функций. В дальнейшем происходит их вызов.

Производим расчет для индекса<br>
#### local So = Short_MA(index)<br>
#### local Lo = Long_MA(index)<br>

Получаем значения из полученных массивов<br>
#### t_MACD[index] = So[index] - Lo[index]<br>

Производим расчет и получаем значение для индекса для метода над массивом t_MACD<br>
#### s_MACD[index] = MACD_MA(index)[index]